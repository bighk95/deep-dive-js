<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> 함수 </title>
</head>
<body>
<script>
    // [1]. 함수 (function)
    
    // 함수는 js에서 가장 중요한 핵심 개념. 
    // 수학에서의 함수는 입력 (input)을 받아 출력 (output)을 내보내는 일련의 과정을 정의한 것.
    // f(x,y) = x + y 라는 함수를 정의하고 이 함수에 두개의 입력 2, 5를 전달하면 함수는 정의된 일련의 과정, x + y 를 실행하여 7을 출력.
    // 이를 수식으로 표현하면 f(2,5) = 7. 이때의 함수의 x, y는 함수 내부로 입력을 받아들이는 변수이고 2, 5는 함수를 실행하기 위한 입력이며, 7은 결과의 출력.
    
    // 이때 함수를 실행하기 위해 필요한 입력인 2, 5는 압력을 받아들이는 변수 x, y를 통해 함수 외부에서 함수 내부로 전달됨. 실행 결과인 출련은 함수 외부로 반환됨.
    // 프로그래밍 언어의 함수도 수학의 함수와 같은개념. 
    ex) //f(x,y) = x + y
        function add(x,y) {
            return x + y;
    }
        add(2,5)  //  7

    // 프로그래밍 언어의 하수는 일련의 과정을 문 (statement)로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한 것.
    // 프로그래밍 언어의 함수도 입력을 받아서 출력을 내보냄.
    // 이때 함수 내부로 입력을 전달받는 변수를 매개변수 (parameter), 입력을 인수 (argument), 출력을 반환값 (return value) 라고 함.
    // 또한 함수는 값이며, 여러개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별장니 함수 이름을 사용할 수 있음.
    
    // 함수는 함수 정의 (function definition)을 통해 생성. js의 함수는 다양한 방법으로 정의할 수 있음

    ex) function add(x,y) {  //  함수 정의
        return x + y;
    }

    // 함수 정의만으로 함수가 실행되는것은 아니며, 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시해야 함.
    // 이를 함수 호출 (function call / invoke) 라고 함. 함수를 호출하면 코드블록에 담긴 문들이 일괄적으로 실행되고 결과를 반환함.
    
    ex) function add(x,y) {  //  함수 정의
        return x + y;
    }
        var result = add(2,5);  //  함수 호출
        console.log(result);  //  7

    // [2]. 함수를 사용하는 이유
    
    // 함수는 필요할 때 여러번 호출할 수 있음, 즉 실행지점을 개발자가 결정할 수 있고 몇번이든 재사용이 가능.
    // 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 중복해서 여러번 작성하는것이 아니라 미리 정의된 함수를 재사용하는것이 효율적.
    // 함수를 몇번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용함.
    // 함수는 코드의 중복을 억제하고 재사용성을 높이므로, 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있음.

    // 하수는 객체 타입의 값. 따라서 이름 (식별자) 를 붙일 수 있음.
    // 함수의 이름은 변수 이름과 마찬가지로 함수 자신의 역할을 잘 설명해야함.
    // 적절한 함수 이름은 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕고, 코드의 가독성을 향상시킴.
</script>

<script>
    // [3]. 함수 리터럴

    // js의 함수는 객체 타입의 값. 따라서 숫자값을 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있음.
    // 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성.
    
    ex) var f = function add(x,y) {  //  변수에 함수 리터럴을 할당
            return x + y;
    };

    // 위 예제에서 함수 리터럴을 변수에 할당하고 있음. 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기방식
    // 리터럴은 값을 생성하기 위한 표기법. 따라서 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체. 즉, 함수는 객체.

    // 함수는 객체이지만, 일반 객체와 다름. 일반 객체는 호출할 수 없지만, 함수는 호출할 수 있음.
    // 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 가짐.
    // 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 js의 중요한 특징.
</script>

<script>
    // [4]. 함수 정의

    // 함수 정의란 함추를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환한 값을 지정하는 것.
    // 정의된 함수는 js 엔진에 의해 평가되어 함수 객체가 됨. 함수를 정의하는 방법은 4가지.
    // 1) 함수 선언문
    ex) function add(x,y) {
        return x+y;
    }

    // 2) 함수 표현식
    ex) var add = function (x,y) {
        return x+y;
    };

    // 3) Function 생성자 함수
    ex) var add = new Function('x', 'y', 'return x+y');

    // 4) 화살표 함수 (ES6)
    ex) var add = (x,y) => x+y;

    // 모든 함수 정의 방식을 함수를 정의한다는 면에서 동일하지만 차이가 있음.
    // 변수는 선언 (declaration) 하지만, 함수는 정의 (definition) 한다고 표현.
    // 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당.
    // 따라서 ECMAScript 사양에서도 변수에는 선언, 함수에는 정의라고 표현함.
</script>

<script>
    // [4-1]. 함수 선언문

    ex) function add(x,y) {  //  함수 선언문
            return x+y;
    }
    console.dir(add);  //  f add(x,y)  //  console.dir은 console.log 와 다르게 함수 객체의 프로퍼티까지 출력 (Node.js 에서는 console.log 와 같은 결과가 출력)
    console.log(add(2,5));  //  7  //  함수 호출

    // 함수 선언문은 함수 리터럴과 형태가 동일. 단 함수 리터럴은 함수 이름을 생략할 수 있으나, 함수 선언문은 함수 이름을 생략할 수 없음.
    
    ex) function (x,y) {
        return x+y;
    }
    // SyntaxError: Function statements require a function name

    // 함수 선언문은 표현식이 아닌 문. 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료값 undefined가 출력됨.
    // 함수 선언문이 만약 표현식인 문이라면 완료값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 함.
    // 표현식이 아닌 문은 변수에 할당할 수 없음. 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없으나, 함수 선언문이 변수에 할당되는 것처럼 보일때가 있음.
    
    ex) var add = function add (x,y) {
            return x+y;
    };
    console.log(add(2,5));  //  7  //  함수호출

    // 이렇게 동작하는 이유는 js 엔진이 코드의 문맥에 따라
    // 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문으로 해석하는 경우가 있기 때문.
    // 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일.
    // 이는 함수 이름이 있는 기명 함수 리터럴은 함수 선운문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 의미.
    
    // 예를들어, {} 는 블록문일 수도 있고, 객체 리터럴일 수도 있음. {} 은 중의적 표현.
    // js 엔진은 {} 처럼 중의적인 코드는 코드의 문맥에 따라 달리 해석함.
    // {}이 단독으로 존재하면 js 엔진은 {} 을 블록문으로 해석함.
    // {}이 값으로 평가되어야 할 문맥 (ex) 할당 연산자의 우변) 에서 피연산자로 사용되면 js 엔진은 {} 을 객체 리터럴로 해석함.
    // 이처럼 동일한 코드도 코드의 문맥에 따라 해석이 달라질 수 있음.

    // 기명 함수 리터럴도 중의적인 코드. 따라서 코드의 문맥에 따라 해석이 달라질 수 있음.
    // js 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석, 함수 리터럴이 값으로 평가되어야 하는 문맥에서는 함수 리터럴 표현식으로 해석함.
    // 이때 함수 선언문이든 함수 리터럴 표현식이든 함수가 생성되는 것은 동일. 하지만 함수를 생성하는 내부 동작에는 차이가 있음

    ex) function foo() { console.log('foo'); }  //  기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석, 선언문은 함수 이름을 생략할 수 없음.
        foo();  //  foo

        (function bar() { console.log('bar'); });  //  함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석, 리터럴 표현식을 이름을 생략할 수 있음.
        bar();  //  ReferenceError: bar is not defined

    // 위 예제에서 단독으로 사용된 함수 리터럴 (foo)은 함수 선언문으로 해석, 
    // 그룹 연산자 () 내에 있는 함수 리터럴 (bar)은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석.
    // 함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있음.
    // 위 예제에서 함수 선언문을 생성된 foo 는 호출할 수 있지만, 함수 리터럴 표현식으로 생성된 bar 는 호출할 수 없음.

    // 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자. 이는 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로
    // 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미. 즉, 함수를 가리키는 식별자가 없다는 것과 같으므로 bar 함수는 호출할 수 없음.

    // foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름이므로 foo로 함수를 호출할 수 없어야함.
    // foo 라는 이름으로 함수를 호출하려면 foo는 함수 이름이 아니라 함수 객체를 가리키는 식별자여야 함.
    // 위 예제에서는 식별자 foo를 선언한 적도 없고, 할당한 적도 없음.
    // foo는 js 엔진이 암묵적으로 생성한 식별자인것

    // js 엔진은 함수 선언문을 해석해 함수 객체를 생성. 이때 함수 이름은 함수 몸채 내부에서만 유효한 식별자이므로
    // 함수 이름과는 별도로 생성된 함수 객체를 가리키는 식별자가 필요함. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 참조할 수 없으므로, 호출할 수도 없음.
    // 따라서 js 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당함.

    // 정리
    // 함수 리터럴 표현식으로 생성된 함수는 js 엔진이 암묵적으로 함수 외부의 식별자를 생성하지 않아, 함수를 호출할 수 없음.
    // 함수 선언문으로 생성된 함수는 js 엔진이 암묵적으로 함수 외부의 식별자를 생성하여, 함수를 호출할 수 있음.
    
    ex) var add = function add(x,y) {
            return x+y;
    }
    console.log(add(2,5));  //  7

    // 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함.
    // 함수 선언문으로 생성한 함수를 호출한 것은 함수 이름 add가 아니라, js 엔진이 암묵적으로 생성한 식별자 add인것.
    // 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는것 처럼 보이기도 하지만, 사실 식별자로 호출된 것.
    // 결론적으로 js 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있음. 단, 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아님.
</script>

<script>
    // [4-2]. 함수 표현식
    
    // js의 함수는 객체 타입의 값. js의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있음.
    // 이처럼 값의 성질을 갖는 객체를 일급 객체라 함. js의 함수는 일급 객체. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미.
    
    // 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있음.
    // 이러한 함수 정의 방식을 함수 표현식 (function expression)이라 함. 함수 선언문으로 정의한 add 함수를 함수 표현식으로 바꿔서 정의할 수 있음
    ex) var add = function (x,y) {
            return x+y;
    };
    console.log(add(2,5));  //  7

    // 함수 리터럴의 함수 이름은 생략할 수 있음. 이러한 함수를 익명 함수라고 함. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적.
    // 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야함. 함수 이름은 몸체 내부에서만 유효한 식별자 이므로 함수 이름으로 호출할 수 없음.

    ex) var add = function foo (x,y) {  //  기명 함수 표현식
            return x+y;
    };
    console.log(add(2,5));  //  7  //  함수 객체를 가리키는 식별자로 호출
    console.log(foo(2,5));  //  ReferenceError: foo is not defined  //  함수 이름으로 호출

    // js 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보임.
    // 하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지 않음.
    // 함수 선언문은 "표현식이 아닌 문" (값으로 할당할 수 없음) 이고 함수 리터럴 표현식은 "표현식인 문" (값으로 할당할 수 있음).
</script>

<script>
    // [4-3]. 함수 생성 시점과 함수 호이스팅

    ex) console.dir(add);  //  f add(x,y)
        console.dir(sub);  //  undefined  //  함수 호이스팅이 아닌 변수 호이스팅이 발생함

        console.log(add(2,5));  //  7
        console.log(sub(2,5));  //  TypeError: sub is not a function

        function add(x,y) {  //  함수 선언문
            return x+y;
        }

        var sub = function (x,y) {  //  함수 표현식
            return x-y;
        };

    // 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음.
    // 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음.
    // 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문.

    // 모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 js 엔진에 의해 먼저 실행됨.
    // 함수 선언문으로 정의하면 런타임 이전에 함수 객체가 먼저 생성, 그리고 js 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당함.
    // 즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료한 상태임.
    // 함수 선언문 이전에 함수를 참조할 수 있으며 호출도 할 수 있음.
    // 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 js 고유의 특징을 함수 호이스팅 (function hoisting).
    
    // 함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있으므로 주의할 것.
    // var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 js 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일.
    // 하지만 var 키워드로 선언된 변수는 undefined로 초기화 되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화됨.
    // var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만,
    // 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능함.

    // 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작.
    // 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만 변수 할당문의 값은 할당문이 실행되는 시점,
    // 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨.
    // 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는것이 아니라 변수 호이스팅이 발생함.
    
    // 함수 표현식 이전에 함수를 참조하면 unedefined로 평가함. 따라서 이때 함수를 호출하면 undefined를 호출하는것과 마찬가지이므로 타입에러가 발생.
    // 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야함.
    // 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시함.
    // 이 같은 문제 때문에 JSON (JavaScript Object Notation)을 창안한 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권장함.
</script>

<script>
    // [4-4]. Function 생성자 함수

    // js가 기본제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면
    // 함수 객체를 생성해서 반환함. 사실 new 연산자 없이 호출해도 결과는 동일

    // 생성자 함수 (constructor function) 는 객체를 생성하는 함수. 객체를 생성하는 방식은 다양한 방법이 있음

    ex) var add = new Function('x', 'y', 'return x+y');
            console.log(add(2,5));  //  7

    // Function 생성자 함수로 함수를 생성하는 방식을 일반적이지 않으며 바람직하지도 않음.
    // Function 생성자 함수로 생성한 함수는 클로저 (closure)를 생성하지 않는 등, 함수 선언문이나 함수 표현식을 생성한 함수와 다르게 동작함.

    ex) var add1 = (function () {
        var a = 10;
            return function (x,y) {
                return x+y+a;
            };
        }());

        console.log(add1(1,2));  //  13

        var add2 = (function () {
        var a = 10;
            return new Function('x', 'y', 'x+y');
        }());

        console.log(add2(1,2));  //  ReferenceError: a is not defined

        // 함수 선언문이나 함수 표현식으로 생성한 함수와 Function 생성자 함수로 생성한 함수가 동일하게 동작하지 않음.
</script>

<script>
    // [4-5]. 화살표 함수

    // ES6에서 도입된 화살표 함수 (arrow function) 은 function 키워드 대신 화살표 (fat arrow) =>를 사용해 좀더 간략한 방법으로 함수를 선언함.
    // 화살표 함수는 항상 익명함수로 정의.

    ex) const add = (x,y) => x+y;
            console.log(add(2,5));  //  7

    // 화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된 것은 아님
    // 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화 되어있음.
    // 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며, arguments 객체를 생성하지 않음.
</script>

<script>
    // [5]. 함수 호출
    
    // 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출함. 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열.
    // 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮김. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행.

    // [5-1]. 매개변수와 인수

    // 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수 (parameter; 인자) 를 통해 인수 (argument) 를 전달.
    // 인수는 값으로 평가될 수 있는 표현식이어야 함. 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없음.
    
    ex) function add(x,y) {
        return x+y;
    }  //  함수 선언문

    var result = add(1,2);  //  함수 호출, 인수 1과 2가 매개변수 x, y에 순서대로 할당되고 함수 몸체의 문들이 실행됨.

    // 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급됨.
    // 즉 함수가 호출되면 함수 몸체 내에서 함묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당.
    // 함수가 호출될 때마다 매개변수는 이와 같은 단계를 거침.
    // 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없음.
    // 즉 매개변수의 스코프 (유효범위) 는 함수 내부.

    ex) function add(x,y) {
        console.log(x,y);  //  7
        return x+y;
    }
    add(2,5);

    console.log(x,y);  //  ReferenceError: x is not defined  //  add 함수의 매개변수 x,y는 함수 몸체 내부에서만 참조할 수 있음.

    // 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음.
    // 즉 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지 않음.
    // 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined

    ex) function add(x,y) {
        return x+y;
    }
    console.log(add(2));  //  Nan  -> 2 + undefined 이기 때문

    // 매개변수 x에는 인수 2가 전달되지만, 매개변수 y에는 전달할 인수가 없음.
    // 따라서 매개변수 y는 undefined로 초기화된 상태 그대로이므로 함수 몸체의 문 x+y는 2+undefined와 같으므로 NaN.
    // 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시하며, 에러가 발생하지 않음

    ex) function add(x,y) {
        return x+y;
    }
    console.log(add(2,5,10));  //  7

    // 사실 초과된 인수가 그냥 버려지는것은 아니고, 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관됨.

    ex) function add(x,y) {
        console.log(arguments);  //  Arguements(3) [2, 5, 10, callee: f, Symbol(Symbol.iterator): f]
        
        return x+y;
    }
    add(2,5,10);

    // arguemets 객체는 함수를 정의할 때 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용함.
</script>

<script>
    // [5-2]. 인수 확인

    ex) function add (x,y) {
        return x+y;
    }

    // 위 함수를 정의한 개발자의 의도는 아마도 2개의 숫자 타입 인수를 전달받아 그 합계를 반환하려는 것으로 추측.
    // 하지만 코드상으로는 어떤 타입의 인수를 전달해야 하는지, 어떤 타입의 값을 반환하는지 명확하지 않음. 따라서 위 함수는 다음과 같이 호출될 수 있음.
    
    ex) function add(x,y) {
            return x+y;
    }
    
    console.log(add(2));  //  NaN
    console.log(add('a', 'b'));  //  'ab'

    // 위 코드는 js 문법상 어떠한 문제도 없으므로 js 엔진은 개발자의 의도와 달리 아무런 이의 제기없이 위 코드를 실행할 것임. 그 이유는
    // 1) js 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음.
    // 2) js 는 동적 타입 언어. 따라서 js 함수는 매개변수의 타입을 사전에 지정할 수 없음.
    // 따라서 js의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음.

    ex) function add(x,y) {
        if (typeof x !== 'number' || typeof y !== 'number') {
            throw new TypeError('x, y에 숫자를 기입하여 주세요.');
        }

        return x+y;
    }

    console.log(add(2));  //  TypeError: x, y에 숫자를 기입하여 주세요.
    console.log(add('a','b'));  //  TypeError: x, y에 숫자를 기입하여 주세요.

    // 이처럼 함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수는 없고, 에러는 런타임에 발생하게 됨.
    // 따라서 타입스크립트와 같은 정적 타입을 선언할 수 있는 js의 상위 확장을 도입해서 컴파일 시점에 부적절한 호출을 방지할 수 있게 하는 것도 하나의 방법.
    // 예제에서는 인수의 개수는 확인학 있지 않지만 argumnets 객체를 통해 인수 개수를 확인할 수도 있음.
    // 또한 인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당하는 방법도 있음

    ex) function add(a,b,c) {
        a = a || 0;
        b = b || 0;
        c = c || 0;
        return a+b+c;
    }
    console.log(add(1,2,3));  //  6
    console.log(add(1,2));  //  3
    console.log(add(1));  //  1
    console.log(add());  //  0

    //ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있음.
    // 매개변수 기본ㄱ밧을 매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효함.

    ex) function add(a=0, b=0, c=0) {
            return a+b+c;
    }
    console.log(add(1,2,3));  //  6
    console.log(add(1,2));  //  3
    console.log(add(1));  //  1
    console.log(add());  //  0
</script>

<script>
    // [5-3]. 매개변수의 최대개수

    // ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않음.
    // 하지만 물리적학적 한계는 있으므로 js 엔진마다 매개변수의 최대 개수에 대한 제한이 있겠지만 충분히 많은 매개변수를 지정할 수 있음.
    
    // 매개변수는 순서에 의미가 있음. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야함.
    // 이는 함수의 사용법을 이해하기 어렵게 만들고 실수를 발생시킬 가능성을 높임.
    // 또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받으므로 유지보수성이 나빠짐.

    // 함수의 매개변수는 코드를 이해하는데 방해되는 요소이므로 이상적인 매개변수 개수는 0개이며, 적을수록 좋음.
    // 매개변수의 개수가 많다는것은 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않음.
    // 이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 함.
    // 따라서 매개변수는 최대 3개 이상을 넘지 않는것을 권장. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체로 인수를 전달하는것이 유리함.
    // 다음은 jQuery의 ajax 메서드에 객체를 인수르 전달하는 예

    ex) $.ajax({
        method: 'POST',
        url: '/user',
        data: { id: 1, name: 'Park'},
        cache: false
    });

    // 객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 됨.
    // 또한 명시적으로 인수의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과가 있음.
    // 하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과 (side effect)가 발생한다는 것.
</script>

<script>
    // [5-4]. 반환문

    // 함수는 return 키워드와 표현식 (반환값) 으로 이뤄진 반환문을 사용해 실행 결과를 함수 이부로 반환 (return) 할 수 있음.

    ex) function multiply(x,y) {
        return x*y;  //  반환문
    }

    var result = multiply(3,5);  //  함수 호출은 반환값으로 평가됨.
    console.log(result);  //  15

    // multiply 함수는 두개의 인수를 전달받아 곱한 결과값을 return 키워드를 사용해 반환.
    // 함수는 return 키워드를 사용해 js 에서 사용 가능한 모든 값을 반환할 수 있음.
    // 함수 호출은 표현식. 함수 호출 표현식은 return 키워드가 반환한 표현식의 평가 결과이므로 반환값으로 평가됨.
    // 반환문은 두가지 열학을 함. 첫째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감. 따라서 반환문 이후에 다른문이 조잰하면 그 문은 실행되지 않고 무시됨.

    ex) function multiply(x,y) {
        return x*y;
        console.log('실행되지 않는다.');  //  반환문 이후에 다른문이 존재하면 그 문은 실행되지 않고 무시됨.
    }
    console.log(multiply(3,5));  //  15

    // 둘째, 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환함. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환.

    ex) function foo () {
        return;
    }
    console.log(foo());  //  undefined.

    // 반환문은 생략할 수 있음. 이때 함수는 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환함.
    
    ex) function foo() {
    }
    console.log(foo());  //  undefined

    // return 키워드와 반환값으로 사용할 표현식 사이에 줄바꿈이 있으면, 세미콜론 자동 삽입 기능에 의해 세미콜론이 추가되어 다음과 같이 의도치 않은 결과가 발생할 수 있음.
    
    ex) function multiply(x,y) {
            return  //  return; 으로 해석하여 undefined 기본값을 설정
            x*y;  //  반환문 뒤에 문은 무시됨.
    }
    console.log(multiply(3,5));  //  undefined

    // 반환문은 함수 몸체 내부에서만 사용할 수 있음. 전역에서 반환문을 사용하면 문법 에러 (SyntaxError: Illegal return statement) 발생.
    // 참고로 Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 가짐.
    // 따라서 Node.js 환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않음.
</script>

<script>
    // [6]. 참조에 의한 전달과 외부 상태의 변경

    // 원식밧은 값에 의한 전달 (pass by value), 객체는 참조에 의한 전달 (pass by reference) 방식으로 동작.
    // 매개 변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따름.
    // 함수를 호출하면서 매개변수에 값을 전달하는 방식을 값에 의한 호출 (call by value), 참조에 의한 호출 (call by referecne)로 구별해 부르는 경우도 있으나,
    // 동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일

    ex) function changeVal(primitive, obj) {  //  매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받음
        primitive += 100;
        obj.name = 'Park';
    }
    
    var num = 100;  //  외부상태
    var person = { name: 'Jo' };

    console.log(num);  //  100
    console.log(person);  //  {name: 'Jo'}

    changeVal(num, person);  //  원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달됨.

    console.lg(num);  //  100  //  원시값은 원본이 훼손되지 않음.
    console.log(person);  //  {name: 'Park'}  //  객체는 원본이 훼손됨.
    console.log(123);
</script>
</body>
</html>