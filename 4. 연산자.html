<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> 연산자 </title>
</head>
<body>
<!-- <br><br><br><br><br><br><br><br><br><br> <h1> 연산자 </h1> <br><br><br><br><br><br><br><br><br><br> -->

<script>
    // [1]. 연산자
    // 연산자 (operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만듦.
    // 이때 연산의 대상을 피연산자 (operand)라 하며, 피연산자는 값으로 평가될 수 있는 표현식 이어야 함.
    // 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식임.
</script>

<script>
    // [2]. 산술 연산자 (arithmetic operator)
    // 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만듦.
    // 신술 연산이 불가능한 경우, NaN을 반환함.

    
    // [2-1]. 이항 산술 연산자 (binary arithmetic operator)
    // 2개의 피연산자를 산술연산하여 숫자값을 만듦.
    // 모든 이항 산술 연산자는 피연사자의 값을 변경하는 부수효과 (side-effect)가 있음.
    // 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 것이 아니라, 새로운 값을 만드는 것.
    // (+), (-), (*), (/), (%) 이 있다.


    // [2-2]. 단순 산술 연산자 (unary arithmetic operator)
    // 단순 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자값을 만듦.
    // (++, 증가), (--, 감소), (+, 어떠한 효과도 없음, 음수를 양수로 반전하지도 않음), (-, 양수를 음수로, 음수를 양수로 반전한 값을 반환함)
    // (++), (--)는 부수효과가 있음, (+), (-)는 부수효과가 없음.
    // 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄짐.
    // 증가/감소 (++/--) 연산자는 위치에 의미가 있음.
    // 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소를 수행한 후, 다른 연산을 수행함.
    // 피연산자 뒤에 위치한 전위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소를 수행함.

    // ex) var x = 5, result; 일때
    // 1) result = x++;  /  console.log(x);     -> 5 / 6
    // 2) result = ++x;  /  console.log(x);     -> 6 / 6
    // 3) result = x--;  /  console.log(x);     -> 5 / 4
    // 4) result = --x;  /  console.log(x);     -> 4 / 4

    // 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환함.
    // 이때 피 연산자를 변경하는것이 아니라, 숫타타입으로 변환한값을 새로 생성하여 반환하는 것이므로 부수효과는 없음.

    // [2-3]. 문자열 연결 연산자
    // + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함.
    // '1' + 2 = 12  /  1 + '2' = 12  /  1 + true = 2  /  1 + false = 1  /  1 + null = 1  / 1 + undefined = NaN
    // 개발자의 의도와는 상관없이 js 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 함.
    // 1 + true 를 연산하면 js 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자타입인 1로 강제로 변환한 후 연산을 수행하여 반환함.
    // 이를 암묵적 타입 변환 (implicit coercion) 또는 타입 강제 변환 (type coercion) 이라고 함.
</script>

<script>
    // [3]. 할당 연산자 (assignment operator)
    // 할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당하는 것.
    // 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수효과가 있음.
    // (=), (+=), (-=), (*=), (/=), (%=)
    // ex) var x = 10,
    // 1) x += 5;  /  console.log(x);     -> 15
    // 2) x -= 5;  /  console.log(x);     -> 5
    // 3) x *= 5;  /  console.log(x);     -> 50
    // 4) x /= 5;  /  console.log(x);     -> 2
    // 5) x %= 5;  /  console.log(x);     -> 0

    // var str = 'My name is ';
    // str += 'Lee';  -> str = str + 'Lee'
    // console.log(str);     -> My name is Lee

    // 할당문은 표현식인 문인가, 표현식이 아닌문인가
    // ex) var x;
    //      console.log(x = 10);     -> 10
    // 할당문은 변수에 값을 할당하는 부수효과만 있을뿐 값으로 평가되지 않을것 처럼 보이지만, 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨.
    
    // ex ) var a, b, c;
    //          a = b = c = 0;
    //          console.log(a, b, c);     -> 0 0 0
</script>

<script>
    // [4]. 비교연산자 (comparison operator) 
    // 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언값을 반환함, if문과 for문과 같은 제어문의 조건식에서 주로 사용함.
    // 
    // [4-1]. 동등/일치 비교 연산자
    // 동등 비교 (loose equality) 연산자와 일치 비교 (strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언값을 반환함.
    // 하지만 비교하는 엄격성의 정도가 다름, 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 함.
    // (==, 동등 비교), (===, 일치 비교), (!=, 부동등 비교), (!==, 불일치 비교)
    // x == y: x와 y의 값이 같음,  x === y: x와 y의 값과 타입이 같음.
    // 개발자의 의도와는 상관없이 js엔진에 의해 암묵적으로 타입이 자동변환 되기도 함 (암묵적 타입 변환)
    // 동등 비교 (==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함.
    // 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환함.
    // ex) 5 == 5;     -> true  //  5 == '5';     -> true (숫자5와 문자열5의 차이가 있지만, 암묵적으로 타입을 변환시켜 값이 같으면 true를 반환)
    // 동등 비교 연산자는 편리한 경우도 있지만, 결과를 예측하기 어렵고 실수하기 쉬움.
    // ex) '0' == '';     -> false
    //     0 == '';       -> true
    //     0 == '0';      -> true  //  a=b, a=c일때, b=c (X)
    //     
    //     false == 'false';     -> false
    //     false == '0';         -> true
    //     false == 0;           -> true
    //     false == null;        -> false
    //     false == undefined    -> false
    // 이처럼 동등 비교 (==) 연산자는 예측하기 어려운 결과를 만들어냄. 따라서 동등 비교 연산자는 사용하지 않는것이 좋음.
    // 대신 엄격한 비교기준을 가진 일치 비교 연산자 (===)를 사용함.
    //
    // 일치 비교 (===) 연산자는 좌항과 우항의 피연산자가 타입도 같고, 값도 같은 경우에 한하여 true를 반환함.
    // 다시말해 일치 비교 연산자의  비교 실행에 있어, 암묵적 타입 변환이 발생하지 않음. (일치 비교 연산자의 결과는 예측하기 쉬움)
    // ex) 5 === 5;     -> true,  //  5 === '5';     -> false
    // 일치 비교 연산자에서 주의할 것은 NaN 과 0.
    // NaN === Nan;     -> false  (NaN은 자신과 일치하지 않는 유일한 값. 따라서 숫자가 NaN 인지 조사하려면 빌트인 함수 Number.isNaN을 사용함)
    // ex) Number.isNaN(NaN);            -> true
    //     Number.isNaN(10);             -> false
    //     Number.isNaN(1 + undefined)   -> true
    // 
    // js에는 양의 0과 음의 0이 있는데, 이들을 비교하면 true를 반환함.
    // ex) 0 === -0;     -> true
    //     0 == -0;      -> true
    // 동등 비교 연산자 (==)와 일치 비교 연산자 (===)는 +0과 -0을 동일하다고 평가함. 또한 동일한 값인 NaN과 NaN을 비교하면 다른 값이라고 평가함.
    // ES6에서 도입된 Object.is 메서드는 다음과 같이 예측 가능한 정확한 비교 결과를 반환함. 그 외에는 일치 비교 연산자 (===)와 동일하게 동작함.
    // ex) -0 === +0;             -> true
    //     Object.is(-0, +0);     -> false
    //
    //     NaN === Nan;           -> false
    //     Object.is(NaN, NaN);   -> true
    //
    // 부동등 비교 연산자 (!=) 와 불일치 비교 연산자 (!==)는 각각 동등 비교 (==) 연산자와 일치 비교 (===) 연산자의 반대 개념.
</script>

<script>
    // [5] 삼항 조건 연산자 (ternary oprator)
    // 삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정함. js의 유일한 삼항 연산자이며, 부수효과는 없음.
    // ex) var reuslt = score >= 60 ? 'pass' : 'fail';  ( 조건식 ? 조건식이 true 일때의 반환할 값 : 조건식이 false 일때의 반환할 값. 의 형태)
    //     (score >= 60) === true 일때, pass를 반환.
    //     (score >= 60) === false 일때, fail를 반환.
    // 삼항 조건 연산자는 첫번째 피연산자 (조건식) 이 true로 평가되면 두번째 피연산자 (true일때 반환할 값)을 반환하고,
    // 첫번째 피연산자 (조건식) 이 false로 평가되면 세번째 피연산자 (false 일때 반환할 값)을 반환함.
    // 즉 삼항 조건 연산자는 두번째 피연산자 또는 세번째 피연산자로 평가되는 표현식.
    // 물음표 (?) 앞의 첫번째 피연산자는 조건식, 불리언 타입의 값으로 평가될 표현식. 만약 조건식의 평가결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환됨.
    // 이때 조건식이 참이면 콜론 (:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론 (:) 뒤의 세번째 피연산자가 평가되어 반환됨.
    // ex) var x = 2;
    //     var result = x % 2 ? '홀수' : '짝수';  //  2 % 2 는 0, 0은 false 로 세번째 피연산자인 '짝수'가 평가되어 반환됨.
    //     console.log(result);  //  짝수 
    //
    // 삼항 조건 연산자의 첫번째 피연산자는 조건식이므로 삼항 조건 연산자 표현식은 조건문임.
    // 따라서 if...else 문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리할 수 있음.
    // ex) var x = 2;
    //     if (x % 2) result = '홀수';
    //     else result = '짝수';
    //     console.log(result);
    // 하지만 삼항 조건 연산자 표현식은 if...else문과 중요한 차이가 있음.
    // 삼항 조건 연산자 표현식은 값처럼 사용할수 있지만, if...else문은 값처럼 사용할 수 없음.
    // ex) var x = 10;
    //     var result = if (x % 2) { result = '홀수'; } esle { result = '짝수'; };
    //     SyntaxError: Unexpected token if
    // 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 따라서 삼항 조건 연산자 표현식은 값처럼 다른 표현식의 일부가 될 수 있어 유용함.
    // 조건에 따라 어떤 값을 결정해야 한다면, if...else문 보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다.
    // 하지만 조건에 따라 수행해야 할 문이 하나가 아니라 여러개라면, if...else 문의 가독성이 더 좋음.
</script>

<script>
    // [6]. 논리 연산자 (logical operator)
    // 우항과 좌항의 피연산자 (부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산하며, 부수효과 발생하지 않음.
    // (||, 논리합(OR)), (&&, 논리곱(AND)), (!, 부정(NOT))
    // 논리 부정 (!) 연산자는 언제나 불리언 값을 반환함. 단 피연산자가 반드시 불리언값일 필요는 없음.
    // 만약 피연산자가 불리언 값이 아니라면 불리언 타입으로 암묵적 타입 변환됨.
    // ex) !0;     -> true  /  !'Hello';     -> false
    // 논리합 (||) 또는 논리곱 (&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있음.
    // 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨.
    // ex) 'Cat' && 'Dog';     -> 'Dog'
    // 논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 수 있는데, 드모르간의 법칙을 활용하면 좀 더 가독성 좋은 표현식으로 변환할 수 있음.
    // ex) !(x || y) === (!x && !y)
    //     !(x && y) === (!x || !y)
</script>

<script>
    // [7]. 쉼표 연산자
    // 쉼표 (,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환함.
    // ex) var x, y, z;
    //     x = 1, y = 2, z = 3;     -> 3
</script>

<script>
    // [8]. 그룹 연산자
    // 소괄호 ('()') 로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가함.
    // 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있음. 그룹 연산자는 연산자의 우선순위가 가장 높음.
    // ex) 10 * 2 + 3;       -> 23
    //     10 * (2 + 3);     -> 50
</script>

<script>
    // [9]. typeof 연산자
    // typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환함.
    // "string", "number", " boolean", "undefined", "symbol", "object", "fucntion" 중 하나를 반환함.
    // "null"을 반환하는 경우는 없으며, 함수의 경우 "function"을 반환함. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지 않음.
    // typeof 연산자로 null 값을 연산해보면 "null"이 아닌 "object"를 반환하는데 주의할 것.
    // 이것은 js의 첫번째 버전의 버그인데, 이를 수정함으로써, 기존 코드에 영향을 줄수 있기 때문에 아직까지 수정되지 못하고 있음.
    // 따라서 null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자 === 을 사용할 것.
    // ex) var foo = null;
    //     typeof foo === null;     -> false
    //     foo === null;            -> true
    // 
    // 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 발생하지 않고, undefined를 반환함.
    // ex) typeof unpretty;     -> undefined
</script>

<script>
    // [10]. 지수 연산자
    // ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로 (base), 우항의 피연산자를 지수 (exponent)로 거듭제곱하여 숫자값을 반환함.
    // ex) 2 ** 5;     -> 32
    //     = Math.pow(2, 5);     -> 32  // 지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했음.
    // ex) 2 ** 3 ** 2;     -> 512 (64,X)  // 지수 연산자의 결합 순서는 우항에서 좌항으로 향한다. 우결합성을 갖음.
    // ex) (-5) ** 2     -> 25  // 음수를 거듭제곱의 밑으로 사용하려면 괄호로 묶어서 음수를 괄호로 묶어서 계산해야함.
    // ex) var num = 5;
    //     num **= 2;     -> 25  // 지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있음.
    // ex) 2 ** 5 * 2;     -> 64    //  지수 연산자는 이항 연산자 중에서 우선순위가 가장 높음.
</script>

<script>
    // [11]. 그 외의 연산자
    // 1) ?.  -  옵셔널 체이닝 연산자
    // 2) ??  -  null 병합 연산자
    // 3) delete  -  프로퍼티 삭제 연산자
    // 4) new  -  생성자 함수를 호출할 때 사용하여 인스턴스를 생성
    // 5) instanceof  -  좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
    // 6) in  -  프로퍼티 존재 확인
</script>

<script>
    // [12]. 연산자의 부수효과
    // 대부분의 연산자는 다른 코드애 영향을 주지 않음. 예를들어 1*2는 다른코드에 어떠한 영향도 주지 않고 새로운 값 2를 생성함.
    // 하지만 일부 연산자는 다른 코드에 영향을 주는 부수효과가 있음.
    // 부수 효과가 있는 연산자는 할당 연산자 (=), 증가/감소 연산자 (++/--), delete 연산자.
    // ex) var x;
    //     x = 1;
    //     console.log(x);     -> 1
    // 할당 연산자는 변수값이 변하는 부수효과가 있음. 이는 x 변수를 사용하는 다른코드에 영향을 줌.
    //
    // ex) var x;
    //     x = 1;
    //     x++;
    //     console.log(x);     -> 2
    // 증가/감소 연산자는 피연산자의 값을 변경하는 부수효과가 있음. 피연산자 x의 값이 재할당되어 변경되므로 x 변수를 사용하는 다른코드에 영향을 줌.
    //
    // ex) var o = { a:1, b:2, c:3 };
    //     delete o.a;
    //     console.log(o);     -> {b: 2, c: 3}
    // delete 연산자는 객체의 프로퍼티를 삭제하는 부수효과가 있음. 이는 o 객체를 사용하는 다른코드에 영향을 줌.
</script>
</body>
</html>