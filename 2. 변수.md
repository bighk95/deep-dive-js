# 변수

```html
<div id="counter">0</div>
<button id="increase">+</button>
<button id="decrease">-</button>

```
```javascript
const $counter = document.getElementById('counter');
        const $increase = document.getElementById('increase');
        const $decrease = document.getElementById('decrease');

        let num = 0;
        const render = function () {
            $counter.innerHTML = num;
        };

        $increase.onclick = function () {
            num++;
            console.log(num);
            render();
        };

        $decrease.onclick = function () {
            num--;
            console.log(num);
            render();
        };
```
```javascript
var userId = 1;
    var userName = 'Park';  // 변수는 하나의 값을 저장하기 위한 수단
```
```javascript
var user = {id: 1, Name: 'Park'};  // // 객체나 배열같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용할 수 있음.
```
```javascript
var users = [
            {id: 1, Name: 'Park'},
            {id: 2, Name: 'Kim'},
            {id: 'Master', Name: 'Jjo'}
        ];
```

```javascript
var result = 10 + 20;
```

 ## [1]. 변수에 대한 선언 -> ★let, var , const★
 - ES6에서 let , const가 도입되기 이전에는 var만 존재.
 - var는 여러 단점이 있으며, ★★★대표적으로 블록 레벨 스코프(block-level scope)를 지원하지 않고, 
 - 함수 레벨 스코프(function-level scope)를 지원한다는 것.★★★
 - 이에 대한 부작용으로 ★★★전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.★★★

 - ES5 -> ES6으로 업그레이드 되었지만, ES6는 기본적으로 하위 호환성을 유지하면서 ES5 위에 새로운 기능을 추가한것.
 - =ES6는 ES5의 상위 집합 (superset)
 -    
 - 키워드는 js코드를 해석하고 실행하는 js엔진이 수행할 동작을 규정한 일종의 명렁어.
 - js 엔진은 키워드를 만나면 수행해야할 약속된 동작을 수행.
 - ex) 'var' 키워드를 만나면 js엔진은 'var'뒤에 나오는 이름으로 새로운 변수를 선언.


    
 ## [2]. var

```javascript
var score;
```
 - 위의 변수선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보.
 - 변수를 선언한 이후, 변수가 값을 할당(저장,대입)하지 않았지만
 - js 엔진에 의해 "undefined" 라는 값이 암묵적으로 할당되어 초기화.(js의 독특한 특징) 
 - undefined 는 자바스크립에서 제공하는 원시 타입의 값 (primitive value)
 - js 엔진은 변수선언을 2단계에 거쳐서 수행.
 - 1.선언 단계 : 변수 이름을 등록해서 js 엔진에 변수의 존재를 알린다.
 - 2.초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 값이 저장되어있지 않다면 undefined를 할당해 초기화.


    
 - 변수 이름은 어디에 등록되는가?
 - ★★★변수 이름을 비롯한 모든 식별자 (함수,클래스) 는 실행 컨텍스트에 등록.★★★
 - 실행 컨텍스트는 js 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역.
           => js엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리.
 - 변수 이름과 변수 값은 실행 컨텍스트 내에 키(key) / 값(value) 형식인 객체로 등록되어 관리.


    
 - var 키워드를 사용한 변수 선언은 선언단계와 초기화 단계까 동시에 진행.
 - var score; 는 선언 단계를 통해 변수 이름 score 를 등록하고, 초기화 단계를 통해 undefined를 할당해 초기화.
 - 일반적을 초기화란 변수가 선언된 이후로 최초로 값을 할당하는것.
 - var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동수행.
 - 따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.
 - 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을수 있다.
 - 이러한 값을 쓰레기값 (garvage value)라고 한다.
 - 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수값을 참조하면 쓰레기값이 나올수 있다.
 - ★★★하지만 var 키워드는 암묵적으로 undefined로 초기화를 자동수행하므로 쓰레기값으로부터 안전.★★★


    
 - 모든 식별자 (변수, 함수, 클래스)는 반드시 선언이 필요하다. 선언하지 않은 식별자에 접근하면 ReferenceError(참조에러)가 발생.
 - ReferenceError는 식별자를 통해 값을 참조하려 했지만 js엔진이 등록된 식별자를 찾을수 없을때 발생하는 에러.


    
 ## [3]. 변수 선언의 실행시점과 변수 호이스팅

```javascript
console.log(score);
         var score = 10;
```
 - js 코드는 인터프리터에 의해 한줄씩 순차적으로 실행되므로 console.log(score); 가 실행되고 var score = 10;이 실행되므로
 - console.log가 실행되는 시점에서는 score에 대한 변수 선언이 실행되지 않았으므로 참조에러가 발생될것 처럼 보이지만, undefined가 출력.
 - ★★★그 이유는 변수 선언이 소스코드가 한줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전단계에서 먼저 실행되기 때문.★★★
 - js 엔진은 소스코드를 한줄씩 순차적으로 실행하기에 앞서, 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.
 - 이때 js 엔진은 변수 선언을 포함한 모든 선언문 (변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내어 먼저 실행.
 - 이는 변수 선언 (선언단계와 초기화단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거.
 - ★★★이처럼 변수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 js 고유의 특징을 변수 호이스팅 (variable hoisting) 이라고 한다.★★★
 - 또한 변수 선언문 뿐만 아니라 모든 식별자 (var, let, const, function, class) 는 호이스팅. 
 - 모든 선언문은 런타임 이전에 소스코드 평가과정에서 실행되기 때문.


    
 ## [4]. 값의 할당
 - 변수에 값을 할당(assignment) 할때는 할당 연산자 '='를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당.
```javascript
var score; 
score = 88; 
```
         
 -  이 2문으로 표현한 변수 선언은 하나의 문으로 단축할수 있으며, 이 두가지 경우는 정확히 동일하게 동작. 
 -  (하나로 단축한 문도 변수 선언과 값의 할당으로 나뉘어 실행)
```javascript
var score = 88;
```
 - 주의할 점은 ★★★변수 선언과 값의 할당의 실행시점이 다르다는것.★★★
 - 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행.

```javascript
console.log(score);
var score;   //변수 선언
score = 88;   //값의 할당
console.log(score);
```

 - 첫번째 console.log(score); 에서는 score의 변수 선언에 대해서는 호이스팅에 의해 undefined 되었으나, 
 - 값의 할당(score = 88;)이 실행되기 이전에 실행되었으므로,
 - 첫번째 console.log(score); 에서는 undefined.
 - 두번째 console.log(score); 에서는 score의 변수 선언에 대해 호이스팅 되었건 안되었건 선언문 이후에 실행되므로, 변수 선언이 완료되었고,
 - 값의 할당 (score = 88;) 이후에 실행되었으므로, 두번째 console.log(score); 에서는 88.

```javascript
console.log(score);
var score = 88;
console.log(score);
```
        
 - 위의 변수에 대한 설명을 하나의 문으로 단축하여 표현하여도, 결과는 같다.
 - 첫번째 console.log(score); 에서는 undefined. (변수 선언은 완료하였으나, 값을 할당받지 못했기 때문.)
 - 두번째 console.log(score); 에서는 88. (변수 선언도 완료하였고, 값을 할당받은 후에 console.log를 실행했기 때문.)

 - 단, 변수에 값을 할당할때는 이전 값 undefined가 저장되어있던 메모리 공간을 지우고 그 메모리 공간에 할당값 88을 새롭게 저장하는것이 아니라
 - 새로운 메모리 공간을 확보하고 그 곳에 할당값 88을 저장한다는 점에 주의할것.

```javascript
console.log(score);
score = 80;
var score;
console.log(score);
```

 - 첫번째 console.log(score);는 변수 선언문은 완료하였으나, 값을 할당하기 이전에 실행되었으므로 undefined.
 - 두번째 console.log(score);는 변수 선언문을 완료하였고, 값을 할당한 이후에 실행되었으므로 80.


    
## [5]. 값의 재할당
 - 재할당이랑 이미 값이 할당되어있는 변수에 새로운 값을 다시 할당하는 것.

```javascript
var score = 90;
console.log(score);
score = 80;
console.log(score);
```

 - var 키워드로 선언한 변수는 값을 재할당 할 수 있다.
 - ★★★이전에 저장된 할당값의 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 새롭게 저장하는것이 아니라
 - 새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당값을 저장하는 것.★★★
 - var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에, 엄밀히 말하면 처음으로 값을 할당하는 것도 사실은 재할당.
 - score 변수의 이전값인 처음의 할당값과 undefined는 아무도 사용하고 있지 않으니, 더이상 필요하지 않다는 것을 의미.
 - 불필요한 값들은 가바지 콜렉터에 의해 메모리에서 자동해제된다. 단, 메모리에서 언제 해제되는지는 예측할 수 없다.
 - 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능.
 - 여기서 더이상 사용되지 않는 메모리란, 어떠한 식별자도 참조하지 않는 메모리 공간을 의미.
 - js는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.
 - ★★★민약 값을 재할당할수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant).★★★
 - 상수는 단 한번만 할당할 수 있는 변수.

 - 언매니지드 언어 vs 매니지드 언어 (메모리 관리 방식에 따른 분류)
 - 언매니지드 언어 -> C언어 , 매니지드 언어 -> javascript 언어
 - C 언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 
 - malloc()과 free()같은 저수준(low-level) 메모리 제어 기능을 제공한다.
 - 언매니지드 언어는 메모리 제어를 개발자가 자체적으로 주도하므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만
 - 반대로 치명적 오류를 생상할 수도 있다.
 - javascript 같은 매니지드 언어는 메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고
 - 개발자의 직접적인 메모리 제어를 허용하지 않는다.
 - 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다.
 - 더이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며, 이 또한 개발자가 관여할 수 없다.
 - 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느정도 일정한 생산성을 확보할 수 있다는 장점이 있지만
 - 성능면에서 어느정도의 손실이 발생.


    
 ## [6].const 키워드로의 선언
 - ES6에서 도입된 const 키워드를 사용해 선언한 변수는 재할당이 금지. = const 는 상수를 표현하는 것.
 - 하지만, const 는 반드시 상수만을 위해 사용하지는 않는다.


    
 ## [7]. 식별자 네이밍 규칙
 - 식별자(identifier)는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름.
 - 1) 삭별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)를 포함할 수 있다.
 - 2) 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러기호($)로 시작해야 한다. 숫자로 시작하는것은 허용되지 않는다.
 - 3) 예약어는 식별자로 사용할 수 없다.
 - 예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다.
 - ex) class, const, else, for, function, if, let*, null, return, this, var, while
 - *표시는 식별자로 사용가능하나, strict mode에서는 불가능.
        
 - ex) var person, $elem, _name, first_name, vali;  -> 여러개를 한번에 선언할 수 있지만, 가독성이 나빠지므로 권장하지 않는다.
 - ex) var firstname , var firstName, var FirstName;  -> js는 대소문자를 구별하므로, 다음 변수는 각각 별개의 변수.
 - ex) var x = 3;  -> x변수가 의미하는 바를 알 수 없다. 작성자 본인만 알 수 있으므로, 협업할 수 없고, 사용자또한 알 수 없다.
 - ex) var d;  경과 시간, 단위는 날짜이다.  -> 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 이름인것.
        
 - 네이밍 컨벤션 (naming convention)은 하나 이상의 영단어로 구성된 식별자를 만들때
 - 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다.
 - 필연적인것은 아니나 권장하는것.
 - 4) 카멜 케이스 (camelCase)
 - 5) 스네이크 케이스 (snake_case)
 - 6) 파스칼 케이스 (PascalCase)
 - 7) 헝가리안 케이스 (typeHungarianCase)

 - 일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지만, js에서는 일반적으로 변수나 함수는 카멜케이스를 사용
 - 생성자함수, 클래스의 이름에는 파스칼케이스를 사용.
 - 따라서 코드 전체적인 가독성을 높이려면 카멜케이스와 파스칼케이스를 따르는것을 권장.
