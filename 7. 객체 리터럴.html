<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>객체 리터럴</title>
</head>
<body>
    <!-- <br><br><br><br><br><br><br><br><br><br> <h1> 객체 리터럴 </h1> <br><br><br><br><br><br><br><br><br><br> -->

<script>
    // [1]. 객체 (object) 란 ?
    
    // js는 객체 기반 프로그래밍 언어, js를 구성하는 거의 "모든 것"이 객체임.
    // 원시값을 제외한 나머지 (함수, 배열, 정규 표현식 등등)는 모두 객체.
    // 원시 타입은 하나의 값만 나타내지만 객체 타입 (object/reference type)은 다양한 타입의 값 (원시값 또는 다른객체)을 하나의 단위로 구성한
    // 복합적인 자료구조 (data structure).
    // 원시 타입의 값, 즉 원시값은 변경 불가능한 값 (immutable value) 이지만, 객체 타입의 값, 즉 객체는 변경 가능한 값 (mutable value).
    // 객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키 (key)와 값 (value)으로 구성.
    ex) var person = {
            name : 'Park',
            age : 28
        };
    // ★★★★★여기서 name : 'Park' 과 age : 20 은 프로퍼티 / name, age 는 프로퍼티 키, 'Park'과 28 은 프로퍼티 값 ★★★★★

    // js에서 사용할 수 있는 모든값은 프로퍼티 값이 될 수 있음. js의 함수는 일급 객체 이므로 값으로 취급할 수 있음.
    // 따라서 함수도 프로퍼티 값으로 사용할 수 있음. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드 (method)라 함.
    ex) var counter = {
            num: 0,
            increase: function() {
            this.num++;
            }
        };
    // ★★★★★여기서 num: 0 은 프로퍼티 / increase: function () { this.num++; } 은 메서드 ★★★★★
    // 모든 함수는 메서드라고 할 수 없지만, 모든 메서드는 함수. (함수가 메서드를 포함하는 개념)
    
    // 객체는 프로퍼티와 메서드로 구성된 집합체.
    // 프로퍼티 : 객체의 상태를 나타내는 값 (data)
    // 메서드 : 프로퍼티 (상태 데이터) 를 참조하고 조작할 수 있는 동작 (behavior)
    // 객체는 객체의 상태를 나타내는 값과 프로퍼티를 참조하고 조작할 수 있는 동작을 모두 포함할 수 있기 때문에
    // 상태와 동작을 하나의 단위로 구조화할 수 있어 유용함.
    
    // js의 객체는 함수와 밀접한 관계를 가진다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 함.
    // 함수와 객체는 분리해서 생각할 수 없는 개념. 객체를 이해해야 함수를 제대로 이해할 수 있고, 반대로 함수를 이해해야 객체를 이해할 수 있음.
    // 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체 지향 프로그래밍 이라고 함.
</script>

<script>
    // [2]. 객체 리터럴에 의한 객체 생성
    
    // C++나 자바같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 
    // new 연산자와 함께 생성자 (constructor)을 호출하여 인스턴스를 생성하는 방식으로 객체를 생성.
    // 인스턴스 (instance) 란 클래스에 의해 생성되어 메모리에 저장된 실체. 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념
    // 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 함. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는것에 초점을 맞춘 용어.
    // js는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원함.
    // 객체 리터럴 // object 생성자 함수 // 생성자 함수 // object.create 메서드 // 클래스 (ES6)
    // 이러한 객체 생성 방법 중에서 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법.
    // 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법으로 객체 리터럴은 객체를 생성하기 위한 표기법.
    // 객체 리터럴은 중괄호 ( {...} ) 내에 0개 이상의 프로퍼티를 정의. 변수에 할당되는 시점에 js엔진은 객체 리터럴을 해석해 객체를 생성함.
    ex) var person = {
            name : 'Park',
            sayHello: function () {
                console.log(`Hello! My name is ${this.name}.`);
            }
        };

        console.log(typeof person);  //  object
        console.log(person);  //  {name: 'Park', sayHello: f}

    // 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성됨.
    ex) var empty = {};  //  빈 객체
        console.log(typeof empty);  //  object

    // 객체 리터럴의 중괄호는 코드블록을 의미하지 않는다는데 주의할 것.
    // 코드블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않음. 객체 리터럴은 값으로 평가되는 표현식.
    // 따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙임.
    // 객체 리터럴은 js의 유연함과 강력함을 대표하는 객체 생성 방식. 객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께
    // 생성자를 호출할 필요없음. 숫자값이나 문자열을 만드는 것과 유사하게 리터럴로 객체를 생성.
    // 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프러퍼티를 동적으로 추가할 수 있음.
    // 객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성함.

    // [3]. 프로퍼티
    
    // ★★★★★ 객체는 프로퍼티의 집합, 프로퍼티는 키와 값으로 구성 ★★★★★
    // 프로퍼티를 나열할 때는 쉼표 (,)로 구분. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나, 사용해도 상관없음.
    // 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값으로는
    // 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌값
    // 프로퍼티 값 : js에서 사용할 수 있는 모든값

    // 프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자 역할을 함.
    // 하지만 반드시 식별자 네이밍 규칙을 따라야 하는것은 아니지만 식별자 네이밍 규칙을 따르는 것을 권장.
    // 심벌값도 프로퍼티 키로 사용할 수 있지만 일반적으로는 문자열을 사용함.
    // 프로퍼티 키는 문자열 이므로 따옴표 ('...' 또는 "...")로 묶어야 함.
    // 하지만 식별자 네이밍 규칙을 준수하는 이름 (js에서 사용 가능한 유효한 이름) 은 따옴표를 생략할 수 있음.
    // = 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 함.
    // 식별자 네이밍 규칙을 따르지 않는 프로퍼티 키를 사용하면 번거로운 일이 발생. 가급적 네이밍 규칙을 준수하는 프로퍼티 키 사용을 권장.
    ex) var person = {
            firstName: 'Hyun-Kyu',  //  식별자 네이밍 규칙을 준수하는 프로퍼티 키
            'last-name': 'Park'  //  식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
        };
        console.log(person);  //  {firstName: 'Hyun-Kyu', last-name: 'Park'}

    // 프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수. 따옴표를 생략할 수 있음.
    // 프로퍼티 키로 사용한 last-name은 식별자 네이밍 규칙을 준수하지 않음. 따옴표를 생략할 수 없음.
    // js 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석.
    
    ex) var person = {
            firstName: 'Hyun-Kyu',
            last-name: 'Park'  //  SyntaxError: Unexpected token -
    };

    // 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있음.
    // 이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호 ( [...] ) 로 묶어야 함.
    ex) var obj = {};
        var key = 'hello';

        obj[key] = 'world';  //  ES5: 프로퍼티 키 동적 생성
        //  ES6: 개선된 프로퍼티 이름
        //  var obj = { [key]: 'world'};
        console.log(obj);  //  {hello: 'world'}

    // 빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지 않으나, 키로서의 의미를 갖지 못하므로 권장하지 않음.
    ex) var foo = {
        '': ''  //  빈 문자도 프로퍼티 키로 사용할 수 있음
    };
    console.log(foo);  //  {'': ''}

    // 프로퍼티 키에 문자열이나 심벌값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열로 변환됨.
    // 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환됨.
    ex) var foo = {
        0: 1,
        1: 2,
        2: 3
    };
    console.log(foo);  //  {0: 1, 1: 2, 2: 3}

    // var, function과 같은 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않음.
    // 하지만 예상치 못한 에러가 발생할 여지가 있으므로 권장하지 않음
    ex) var foo = {
            var: '',
            fucntion: ''
    };
    console.log(foo);  //  {var: '', function: ''}

    // 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어씀.
    // 이때 에러는 발생하지 않음
    ex) var foo = {
        name: 'Jo',
        name: 'Park'
    };
    console.log(foo);  //  {name: 'Park'}
</script>

<script>
    // [4]. 메서드 (method)
    
    // js에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다. js의 함수는 일급 객체.
    // 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있음.
    // 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 프로퍼티 값이 함수인것을 메서드라 하며, 객체에 묶여 있는 함수를 의미함.
    ex) var circle = {
            radius: 5;  //  프로퍼티
            getDiameter: function () {  //  메서드
                return 2 * this.radius;  //  this는 circle을 가리킴
            }
        };
        console.log(circle.getDiameter);  //  10
    // 메서드 내부에서 사용한 this 키워드는 객체 자신 (circle 객체)을 가리키는 참조변수

    // [5]. 프로퍼티 접근

    // 프로퍼티에 접근하는 방법
    // 1) 마침표 프로퍼티 접근 연산자 (.)를 사용하는 마침표 표기법 (dot notation)
    // 2) 대괄호 프로퍼티 접근 연산자 ([...])를 사용하는 대괄호 표기법 (bracket notation)

    // 프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름, 즉 js 에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용가능.
    // 마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식을 기술.
    // 마침표 프로퍼티 접근 연산자의 우측 또는 대괄호 프로퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정.
    ex) var person = {
        name: 'Park'
    };
    console.log(person.name);  //  Park  //  마침표 표기법에 의한 프로퍼티 접근
    console.log(person['name']);  //  Park  //  대괄호 표기법에 의한 프로퍼티 접근

    // 대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열일것.
    // 대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 js엔진은 식별자로 해석함.
    ex) var person = {
            name: 'Park'
    };
    console.log(person[name]);  //  ReferenceError: name is not defined
    console.log(person[age]);  // undefined.

    // console.log(person[name]) 에서 에러가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름,
    // 식별자 name을 평가하기 위해 선언된 name을 찾앚지만, 찾지 못했기 때문
    // 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환. 에러가 발생하지 않음에 주의.
    
    // 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, js에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법을 사용해야함.
    // 단, 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표를 생략할 수 있음.
    // 그 외의 경우 대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야함.
    ex) var person = {
            'last-name': 'Park',
            1: 10
    };

    person.'last-name';  //  SyntaxError: Unexpected string
    person.last-name;  //  브라우저 환경 - NaN
                       //  Node.js 환경 - ReferenceError: name is not defined
    person[last-name];  //  ReferenceError: last is not defined
    person['last-name'];   //  Park

    person.1;  //  SyntaxError: Unexpected number
    person.'1';  //  SyntaxError: Unexpected string
    person[1];  //  10  //  person[1] -> person['1']
    person['1'];  //  10

    // 위 예제에서 person.last-name의 실행결과가 브라우저 환경과 Node.js 환경에서 각각 다름.
    // person.last-name을 실행할 때 js 엔진은 먼저 person.last를 평가.
    // person 객체에는 프로퍼티 키가 last 인 프로퍼티가 없기 때문에 person.last는 undefined로 평가.
    // 따라서 person.last-name은 undefined - name 과 같음. (숫자값으로서 - 연산자가 쓰임)
    // 그 다음으로 js 엔진은 name 이라는 식별자를 찾음. 이때 name은 프로퍼티 키가 아니라 식별자로 해석되는것에 주의할 것.

    // Node.js 환경에서는 현재 어디에서 name 이라는 식별자 (변수, 함수등의 이름) 선언이 없으므로
    // ReferenceError 에러가 발생하는데, 브라우저 환경에서는 name 이라는 전역변수 (전역객체 window의 프로퍼티) 가 암묵적으로 존재함.
    // 전역변수 name은 창 (window) 의 이름을 가리키며, 기본값은 빈 문자열.
    // 따라서 person.last-name 은 undefined - '' 과 같으므로 NaN이 됨.
</script>

<script>
    // [6]. 프로퍼티 값 갱신

    // 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 생성.
    ex) var person = {
            name: 'Park'
    };
    person.name = 'Kim';

    console.log(person);  //  {name: 'Kim'}
</script>

<script>
    // [7]. 프로퍼티 동적 생성

    // 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨.
    ex) var person = {
            name: 'Park'
    };
    person.age = 20;  //  person 이라는 객체에는 age라는 프로퍼티가 존재하지 않음, person 객체에 age 프로퍼티가 동적으로 생성, 값이 할당

    console.log(person);  //  {name: 'Park', age: 20}
</script>

<script>
    // [8]. 프로퍼티 삭제

    // delete 연산자는 객체의 프로퍼티를 삭제함. delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함.
    // 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시됨.
    ex) var person = {
            name: 'Park'
    };
    person.age = 28;  //  person 객체에 age 프로퍼티 생성 및 할당
    delete person.name;  //  delete 연산자로 name 프로퍼티 삭제
    delete person.birth;  //  person 객체에 birth 프로퍼티가 존재하지 않으므로 에러 발생하지 않고 무시

    console.log(person);  //  {age: 28}
</script>

<script>
    // [9]. ES6 에서 추가된 객체 리터럴의 확장기능
    
    // [9-1]. 프로퍼티 축약 표현

    // 객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성.
    // 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있음.
    ex) var x = 1, y = 2;
        var obj = {
            x: x,
            y: y
        };
        console.log(obj);  //  {x: 1, y: 2}

    // ES6 에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때
    // 프로퍼티 키를 생략 (property shorthand) 할 수 있음. 이때 프로퍼티 키는 변수 이름으로 자동 생성됨.
    ex) let x = 1, y = 2;
            const obj = {
                x: x, y: y
            };
        console.log(obj);  //  {x: 1, y: 2}

    // 프로퍼티 키와 프로퍼티 값이 동일한 이름일때, 프로퍼티 키를 생략할 수 있음.
    ex) let x = 1, y = 2;
            const obj = { x , y };
        console.log(obj);  //  {x: 1, y: 2}
</script>

<script>
    // [9-2]. 계산된 프로퍼티 이름

    // 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있음
    // 단 프로퍼티 키로 사용할 표현식을 대괄호 ( [...] )로 묶어야 함. 이를 계산된 프로퍼티 이름 (computed property name) 이라 함.
    // ES5에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하려면 객체 리터럴 외부에서 대괄호 ( [...] ) 표기법을 사용해야 함.
    ex) var prefix = 'prop';
        var i = 0;

        var obj = {};
        // 계산된 프로퍼티 이름으로 프로퍼티 키 동적생성
        obj[prefix + '-' + ++i] = i;
        obj[prefix + '-' + ++i] = i;
        obj[prefix + '-' + ++i] = i;

    //     console.log(obj);  //  {prop-1: 1, prop-2: 2, prop-3: 3}

    // ES6 에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있음.
    ex) const prefix = 'prop';
        let i = 0;

        const obj = {
            [`${prefix}-${++i}`]: i,
            [`${prefix}-${++i}`]: i,
            [`${prefix}-${++i}`]: i,
        }  //  객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성

        console.log(obj);  //  {prop-1: 1, prop-2: 2, prop-3: 3}
</script>

<script>
    // [9-3]. 메서드 축약 표현

    // ES5 에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당함.
    ex) var obj = {
        name: 'Park',
        sayHi: function () {
            console.log('Hi! ' + this.name);
        }
    };

    obj.sayHi();  //  Hi! Park

    // ES6 에서 메서드를 정의하려면 function 키워드를 생략한 축약 표현을 사용할 수 있음.
    ex) const obj = {
            name: 'Park',
            sayHi() {  //  메서드 축약 표현
                console.log('Hi !' + this.name);
            }
    };
    obj.sayHi();  //  Hi! Park

    // ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당함 함수와 다르게 동작.
</script>
</body>
</html>