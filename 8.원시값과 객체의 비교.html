<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>원시값과 객체의 비교</title>
</head>
<body>
    <!-- <br><br><br><br><br><br><br><br><br><br> <h1> 원시값과 객체의 비교 </h1> <br><br><br><br><br><br><br><br><br><br> -->

<script>
    // [1]. 들어가며
    
    // "데이터 타입"에서 보았듯, js가 제공하는 7가지 데이터 타입 (숫자, 문자열, 불리언, null ,undefined, 심벌, 객체) 은
    // 크게 원시타입 (primitive type)과 객체타입 (object / reference type) 으로 구분
    // 구분하는 이유? ) 근본적으로 다르기 때문. 크게 3가지 측면에서 다름
    // 1) 원시타입의 값 (원시값) 은 변경 불가능 값, 객체타입의 값 (객체) 변경 가능 값.
    // 2) 원시값을 변수에 할당하면 변수에 실제 값이 저장됨, 객체를 변수에 할당하면 변수에 참조값이 저장됨.
    // 3) 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달됨. (값에 의한 전달, pass by value)
    //    객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨. (참조에 의한 전달, pass by reference)
</script>

<script>
    // [2]. 원시값

    // [2-1]. 변경 불가능한 값.
    
    // 원시타입의 값 (원시값)은 변경 불가능한 값. 한번 생성딘 원시값은 읽기 전용 (read only) 값으로서 변경할 수 없음.
    // 변수는 하나의 값을 저장하기 위해 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
    // 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과.
    // 뱐걍 불가능하다는 것은 변수가 아니라 값에 대한 진술임.
    // 즉, 원시값은 변경 불가능하다는 말은 원시값 자체를 변경할 수 없다는 것. 변수값을 변경할 수 없다는 것이 아님.
    // 변수는 언제든지 재할당을 통해 변수값을 변경 (교체) 할 수 있음.

    // 변수의 상대 개념인 상수는 재할당이 금지된 변수, 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있음.
    // 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 단 한번만 할당이 허용디므로 변수값을 변경할 수 없음.
    // 따라서 상수와 변경 불가능한 값을 동일시 하는것을 곤란하며, 상수는 재할당이 금지된 변수.

    ex) const o = {};  //  const 키워드를 사용해 선언한 변수는 재할당이 금지 (변수가 상수가 됨)
        o.a = 1;
                                 //  const 키워드를 사용해 선언한 변수에 할당한 원시값은 변경할 수 없음
    console.log(o);  //  {a: 1}  //  하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있음
    
    // 원시값은 변경 불가능한 값, 즉 읽기 전용. 원시값은 어떤일이 있어도 불변.
    // 이러한 원시값의 특성은 데이터의 신뢰성을 보장함.
    // 원시값을 할당한 변수에 새로운 원시값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시값을 변경하는것이 아닌,
    // 새로운 메모리 공안을 확보하고 재할당한 원시값을 저장한 후, 변수는 새롭게 재할당한 원시값을 가리킴.
    // 이때 변수가 참조하던 메모리 공간의 주소가 바뀜.

    // 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시값이 변경 불가능한 값이기 때문
    // 만약 원시값이 변경 가능한 값이라면 변수에 새로운 원시값을 재할당했을 때
    // 변수가 가리키던 메모리 공간의 주소를 바꿀 필요없이 같은 메모리 공간에 원시값 자체를 변경하면 될것

    // 하지만 원시값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없음.
    // 따라서 변수값을 변경하기 위해 원시값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후
    // 변수가 참조하던 메모리 공간의 주소를 변경함. 이러한 원시값의 특성을 불변성 (immutability) 라고 함.

    // 불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없음.
    // 만약 재할당 이외에 원시값인 변수값을 변경할 수 있다면 예기치 않게 변수값이 변경될 수 있다는 것을 의미.
    // 이는 값의 변경, 즉 상태 변경을 추적하기 어렵게 만듦.
</script>

<script>
    // [2-2]. 문자열의 불변성

    // 원시값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야함.
    // 이를 위해 원시타입별로 메모리 공간의 크기가 미리 정해져 있음.
    // 단, ECMAScript 사양에 문자열 타입 (2바이트)과 숫자 타입 (8바이트) 이외의 원시타입은 크기를 명확히 규정하지 있지 않아
    // 브라우저 제조사의 구현에 따라서 원시타입의 크기는 다를 수 있음.
    
    // 원시값인 문자열은 다른 원시값과 비교할 때 독특한 특징이 있음.
    // 문자열은 0개 이상의 문자 (character) 로 이뤄진 집합, 1개의 문자는 2바이트의 메모리 공간에 저장.
    // 따라서 문자욜은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정됨.
    // 단순하게 생각하면 1개의 문자로 이뤄진 문자열은 2바이트, 10개의 문자로 이뤄진 문자열은 20바이트의 메모리 공간이 필요함.
    
    // 이 같은 이유로 C에는 하나의 문자를 위한 데이터 타입 (char)만 있을 뿐 문자열 타입은 존재하지 않음.
    // C에서는 문자열을 문자의 배열로 처리하고 자바에서는 문자열을 String 객체로 처리함.
    // 하지만 js는 개발자의 편의를 위해 원시타입인 문자열 타입을 제공함.
    // js의 문자열은 원시타입이며, 변경 불가능함. 이것은 문자열이 생성된 이후에는 변경할 수 없음을 의미함.

    // 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음.
    // 유사 배열 객체 (array-like object) 란 마치 배열처럼 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체
    // 문자열은 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수 도 있음.
    ex) var str = 'string';
        
        console.log(str[0]);  //  s  //  문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있음
        console.log(str.length);  //  6
        console.log(str.toUpperCase());  //  STRING
    
    // 원시값인 문자열이 객체일 수도 있다는 혼란이 있을 수 있지만, 원시값을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환됨.

    ex) var  str = 'string';
        // 문자열은 원시값이므로 변경할 수 없음, 이 때 에러가 발생하지 않음.
        str[0] = 'S';
        console.log(str);  //  string

    // str[0] = 'S' 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않음. 문자열은 변경 불가능한 값이기 때문.
    // 이처럼 한번 생성된 문자열은 읽기 전용 값으로서 변경할수 없음. 원시값은 어떤 일이 있어도 불변.
    // 따라서 예기치 못한 변경으로부터 자유로움. (데이터의 신뢰성 보장)
    
    // 그러나 변수에 새로운 문자열을 재할당하는것은 물론 가능.
    // 이는 기존 문자열을 변경하는것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문.
</script>

<script>
    // [2-3]. 값에 의한 전달
    
    ex) var score = 80;
        var copy = score;

        console.log(score);  //  80
        console.log(copy);  //  80

        score = 100;

        console.log(score);  //  100
        console.log(copy);  //  80

    // score 변수에 숫자값 80을 할당. 그리고 copy 변수에 score 변수를 할당, 그 후 score 변수에 새로운 숫자값 100을 재할당하면 copy 변수의 값은?
    // 위 예제의 핵심은 "변수에 변수를 할당했을때 무엇이 어떻게 전달되는가?"
    // copy = score 에서 score는 변수값 80으로 평가되므로, copy 변수에도 80이 할당될 것. 이 때 새로운 숫자값 80이 생성되어 copy 변수에 할당.
    
    // 이처럼 변수에 원시값을 갖는 변수를 할당하면 할당받는 변수 (copy) 에는 할당되는 변수 (score) 의 원시값이 복사되어 전달됨.
    // 이를 값에 의한 전달 이라고함. copy 변수에 원시값을 갖는 score 변수를 할당하면 할당받는 변수 (copy) 에는 할당되는 변수 (score)의 원시값 80이 복사되어 전달됨.
    
    ex) var score = 80;
        var copy = score;

        console.log(score);  //  80
        console.log(score === copy);  //  true
    
    // 이때 score 변수와 copy 변수는 숫자값 80을 갖는다는 점에서 동일. 하지만 score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값.

    ex) var score = 80;
        var copy = score;

        console.log(score,copy);  //  80 80
        console.log(score === copy);  //  true

        // score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값, score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않음.

        score = 100;

        console.log(score,copy);  //  100 80
        console.log(score === copy);  //  false

    // ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않음.
    // 따라서 실제 js 엔진을 구현하는 제조사에 따라 실제 내부 동작 방식은 미묘한 차이가 있을 수 있음.

    // 또한 "값에 의한 전달" 이라는 용어도 ECMAScript 사양에는 등장하지 않음.
    // "값에 의한 전달"과 "참조에 의한 전달" 이라는 용어를 사용하지만, "공유에 의한 전달 (pass by sharing)" 이라고 표현하는 경우도 있음.

    // 엄격하게 표현하면 변수에는 값이 전달되는것이 아니라 메모리 주소가 전달된다.
    // 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문.
    // 식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름. 값은 메모리 공간에 저장됨.
    // 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 하므로 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있음
    // 식별자로 값을 구별해서 식별한다는 것은 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미. 식별자는 메모리 주소에 붙인 이름.

    ex) var x = 10;
    // 할당 연산자는 숫자 리터럴 10에 의해 생성된 숫자값 10이 저장된 메모리 공간의 주소를 전달. 이로써 식별자 x는 메모리 공간에 저장된 숫자값 10을 식별할 수 있음

    ex) var copy = score;
    // score는 식별자 표현식으로서 숫자값 80으로 평가됨. 이때 두가지 평가 방식이 가능.
    // 1) 새로운 80을 생성 (복사) 하여 메모리 주소를 전달하는 방식, 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 다름.
    // 2) score의 변수값 80의 메모리 주소를 그대로 전달하는 방식, 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 같음.

    // 이처럼 "값에 의한 전달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달. 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.
    // 중요한 것은 변수에 원시값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수중 어느 하나의 변수에 값을 재할당하는 시점이든
    // 결국은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것.
</script>

<script>
    // [3]. 객체

    // 객체는 프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있음. 또한 프로퍼티 값에도 제약이 없음
    // 따라서 객체는 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해둘 수 없음.
    // 객체는 복합적인 자료구조이므로 객체를 관리하는 방식이 원시값과 비교해서 복잡하고 구현방식도 브라우저 제조사마다 다를 수 있음.
    // 원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에 따라 크기가 매우 클 수도 있음.
    // 객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이 드는 일.
    // 따라서 객체는 원시값과는 다른방식으로 동작하도록 설계되어 있음.

    // js 객체의 관리 방식
    // js 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블; hash table (해시 테이블은 연관배열; associative array, map, dictionary, lookup table 이라 부르기도 함)
    // 이라고 생각할 수 있음, 대부분의 js 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현함.
    // 자바, C++ 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체 (인스턴스) 를 생성함.
    // 다시말해, 객체를 생성하기 이전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체를 생성함. 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없음.
    // 하지만 js는 클래스 없이 객체를 생성할 수 있으며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있음.
    // 이는 사용하기 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식.
    
    // 따라서 V8 js 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 (dynamic lookup) 대신 히든 클래스 (hidden class) 라는 방식을 사용해
    // C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장함. 히든 클래스는 자바와 같이 고정된 객체 레이아웃 (클래스) 과 유사하게 동작함.
</script>

<script>
     
</script>
</body>
</html>